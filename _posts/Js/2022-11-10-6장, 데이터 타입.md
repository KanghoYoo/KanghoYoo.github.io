---
title: 5장, 데이터 타입
date: 2022-11-10 +/-TTTT
categories: [JavaScript, JavaScript Deep Dive]
tags: [javascript, javascriptdeepdive] # TAG names should always be lowercase
---

# 🔖 6장, 데이터 타입

```
📌 배운 내용 및 기억하고 싶은 내용
```

- **데이터 타입**은 값의 종류를 의미

| 구분     | 데이터타입     | 설명                                              |
| -------- | -------------- | ------------------------------------------------- |
| 원시타입 | number 타입    | 숫자                                              |
| 원시타입 | string 타입    | 문자열                                            |
| 원시타입 | boolean 타입   | 논리적 true, false                                |
| 원시타입 | undefined 타입 | var 키워드로 선언된 변수에 암묵적으로 할당되는 값 |
| 원시타입 | null 타입      | 값의 없다는 것을 의도적으로 명시할 때 사용        |
| 원시타입 | symbol 타입    | ES6에서 추가된 7번째 타입                         |
| 객체타입 | 객체타입       | 객체, 함수, 배열 등                               |

### 숫자타입

- JS에서는 하나의 숫자 타입만 존재
- 숫자 타입의 값은 배정밀도 64비트 부동소수점 형식을 따름

```javascript
var integer = 25; // 정수
var double = 25.01; // 실수
var negative = -25; // 음의 정수
```

- 정수, 실수, 2진수, 8진수, 16진수 리터럴은 모두 메모리에 배정밀도 64비트 부동소수점 형식의 2진수로 저장
- JS는 2진수, 8진수, 16진수를 표현하기 위한 데이터 타입을 제공하지 않아 값을 참조하면 10진수로 해석

```javascript
var binary = 0b01000001; //2진수
var octal = 0o101; // 8진수
var hex = 0x41; // 16진수

//모두 같은 값
console.log(binary); //65
console.log(octal); //65
console.log(hex); //65
console.log(binary === octal); //true
console.log(octal === hex); //true
```

- JS에서 정수만을 위한 타입은 없으며 모든 수를 실수로 처리함

```javascript
console.log(1 === 1.0) //true
console.log(4/2); //2
console.log(3/2); //1.5
```

- 숫자 타입은 추가적으로 세가지 특별한 값도 표현 가능
  - Infinity : 양의 무한대
  - -Infinity : 음의 무한대
  - NaN : 산술 연산 불가(not-a-number)

```javascript
console.log(10/0); //Infinity
console.log(10/-0); //-Infinity
console.log(1*'String'); //NaN
```

- 대소문자를 구별하는 JS에서는 NaN을 대소문자 구문없이 적으면 참조에러 발생, 식별자로 해석

### 문자열 타입

- **String 타입**은 텍스트 데이터를 나타내는데 사용
- 0개 이상의 16비트 유니코드 문자(UTF-16)의 집합으로 전 세계 대부분 문자 표현 가능
- 문자열은 '', "", 백틱(ES6)으로 텍스트를 감싸지만, JS에서는 일반적으로 **''**을 사용
- ''으로 감싸지 않으면 그 문자는 식별자로 인식되며, 공백 문자도 포함시킬 수 없음
- JS에서 문자열은 원시 타입이며, 변경 불가능한 값(immutable value)
  - 문자열이 생성되면 그 문자열을 변경할 수 없는 것을 의미

### 템플릿 리터럴

- ES6부터 도입
- **템플릿 리터럴**은 멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 편리한 문자열 처리 기능을 제공
- 런타임에 일반 문자열로 변환되어 처리됨
- **벡틱**사용하여 표현

#### 멀티라인 문자열

- 일반 문자열 내에서는 개행이 허용되지 않음
- 이스케이프 시퀀스를 사용해야함

| 이스케이프 시퀀스 | 의미                                                         |
| ----------------- | ------------------------------------------------------------ |
| \0                | Null                                                         |
| \b                | 백스페이스                                                   |
| \f                | 폼피드: 프린터로 출력할 경우 다음 페이지의 시작 지점으로 이동 |
| \n                | 개행(LF): 다음 행으로 이동                                   |
| \r                | 개행(CR): 커서를 처음으로 이동                               |
| \t                | 탭(수평)                                                     |
| \v                | 탭(수직)                                                     |
| \uXXXX            | 유니코드. ex) \u0041 === 'a'                                 |
| \'                | 작은따옴표                                                   |
| \"                | 큰따옴표                                                     |
| \\                | 백슬래시                                                     |

> 라인피드와 캐리지 리턴
>
> - 타자기 커서 제어 방식에서 비롯된 것으로 라인피드는 커서를 정지한 상태에서 종이를 한 줄 올리는 것, 캐리지 리턴은 종이를 움직이지 않고 커서를 맨 앞줄로 이동하는 것
> - 일반적으로 라인피드 사용

- 일반 문자열과 달리 템플릿 리터럴 내에서는 이스케이프 시퀀스를 사용하지 않고도 줄바꿈이 허용되며, 공백도 있는 그대로 적용됨

#### 표현식 삽입

- 문자열 연산자 **+**을 사용하여 문자열을 연결할 수 있음
- 템플릿 리터럴 내에서 표현식 삽입을 통해 간단히 문자열 삽입 가능
  - 문자열 연산자보다 가독성 좋고 간편하게 문자열 조합 가능

```javascript
var fristName = 'Hong';
var lastName = 'Gildong';

//ES6: 표현식 삽입
console.log(`My name is ${firstName} ${lastName}.`); //My name is Hong Gildong
```

- ${ }을 사용하면 표현식의 평가 결과가 문자열이 아니라도 문자열로 타입이 강제로 변환되어 삽입되며 템플릿 리터럴 내에서 사용해야함(벡틱)

### 불리언 타입

- true(참)과 false(거짓)
- 조건문에서 자주 사용

### undefined 타입

- undefined 타입의 값은 undefined가 유일
- 개발자가 의도적으로 할당하기 위한 값이 아니라 JS엔진이 변수를 초기화 할 때 사용하는 값
- var 키워드로 선언한 변수는 undefined로 암묵적으로 초기화
- 변수에 값이 없다는 것을 명시하고 싶을 때는 null사용

### null 타입

- null타입의 값은 null이 유일
- 대소문자 구분
- 값이 없다는 것을 의도적으로 명시할 때 사용
  - 변수가 이전 참조하던 값을 더 이상 참조하지 않겠다는 의미
- 함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도 함

### 심벌 타입

- ES6에서 추가된 7번째 타입
- 변경 불가능한 원시 타입의 값
- 다른 값과 중복되지 않는 유일 무이의 값
- 이름 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용
- Symbol함수를 호출하여 생성
  - 심벌 값은 외부에 노출되지 않으며, 다른 값과 절대 중복되지 않은 유일무이한 값임

### 객체 타입

- 자바스크립트를 이루고 있는 거의 모든 것이 객체임

### 데이터 타입의 필요성

#### 데이터 타입에 의한 메모리 공간의 확보와 참조

- 값은 메모리에 저장하고 참조할 수 있어야 함
- JS에서 숫자 타입의 값을 생성할 때 배정밀도 64비트 부동소수점 형식을 사용

#### 데이터 타입에 의한 값의 해석

- 모든 타입은 데이터 타입을 가지며, 메모리에 비트의 나열로 저장(2진수)
- 데이터 타입이 필요한 이유
  - 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기위해
  - 값을 참조할 때 읽어 들어야 할 메모리 공간의 크기를 결정하기 위해
  - 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

### 동적 타이핑

#### 동적 타입 언어와 정적 타입 언어

- C, Java는 정적 타입언어이며, 변수를 선언할때 데이터 타입을 사전에 선언해야함. (명시적 타입 선언)

  - 변수의 타입 변경 불가능
  - 컴파일 시점에 타입체크를 수행
    - 안정적 코드 구현가능, 런타임 에러 줄임
    - C, C++, Java, Kotlin, Go, Haskell, Rust, Scala 등
- JavaScript는 타입을 선언하지 않으며, 어떤 데이터 타입의 값이라도 자유롭게 할당 가능

  - 값을 할당하는 시점의 타입이 동적으로 결정됨
  - JS의 변수는 선언이 아닌 할당에 의한 타입이 결정(타입 추론)
  - 재할당에 의해 변수의 타입은 언제든 동적으로 변할 수 있음(=동적타이핑)
  - 동적 타입
    - JavaScript, Python, PHP, Ruby, Lisp, Pull 등
- 변수는 타입을 갖지않으며 값은 타입을 가짐

#### 동적 타입 언어와 변수

- 동적 타입 언어는 변수에 어떤 데이터 타입의 값이라도 자유롭게 할당가능
- 단점
  - 복잡한 프로그램에서 변화하는 변수 값을 추적하기 어려움
  - 값의 변경에 의해 타입도 언제든 변경가능하여 값을 확인하기 전에는 타입에 확신할 수 없음
  - 개발자 의도와 상관없이 암묵적으로 타입이 변환되기도함
  - 유연성은 높으나 신뢰성이 떨어짐
- 변수 사용할 때 주의사항
  - 변수는 꼭 필요한 경우에 한해 제한적으로 사용
  - 전역 변수는 최대한 사용하지 않도록 함
  - 변수보다는 상수를 사용해 값의 변경 억제
  - 변수 이름은 변수 목적이나 의미를 파악할 수 있도록 네이밍
    - 가독성이 좋은 코드가 좋은 코드

```
❗️ 읽은 소감
```

> JavaScript는  number, string, boolean, undefined, null, symbol 타입이라는 원시타입과 객체타입으로 구분이 된다. 다른 언어와의 차이라고하면 number타입에서 정수와 실수를 별도의 타입으로 다루지 않고, 하나의 타입으로 처리 한다는 것이다. 별도의 타입은 없지만 `isInteger()` 메서드를 통해 정수인지 실수인지 판별이 가능한 점이 흥미로운것 같다

```
❓ 궁금한 내용이나 잘 이해되지 않는 내용
```

- `> 0.1 + 0.2 === 0.3; //false(0.30000000000000004)`인 이유

  > 실수를 연속된 숫자로 개념적으로 이해하는 사람들과 다르게 컴퓨터에서는 실수를 연속적으로 표현할 수가 없다.
  >
  > 
  >
  > Machine Epsilon
  >
  > 머신 입실론은  특정 시점으로 끊기는 그 수와 수 사이의 간격을 의미한다.
  >
  > 예로, 1/3 즉, 0.333333... 같은 실수의 마지막 값은 일반적으로 2나 4가 되는데 이처럼 컴퓨터가 다룰 수 있는 가장 작은 수를 나타낸다.