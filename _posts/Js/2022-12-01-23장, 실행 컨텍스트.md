---
title: 23장, 실행컨텍스트
date: 2022-12-01 +/-TTTT
categories: [JavaScript, JavaScript Deep Dive]
tags: [javascript, javascriptdeepdive] # TAG names should always be lowercase
---

# 🔖 23장, 실행컨텍스트

## `📌 배운 내용 및 기억하고 싶은 내용`

#### 소스코드 타입의 타입

| 소스코드의 타입 | 설명                                                 |
| --------------- | ---------------------------------------------------- |
| 전역 코드       | 전역에 존재하는 소스코드를 의미                      |
| 함수 코드       | 함수 내부에 존재하는 소스코드를 의미                 |
| eval 코드       | eval 함수에 인수로 전달되어 실행되는 소스코드를 의미 |
| 모듈 코드       | 모듈 내부에 존재하는 소스코드를 의미                 |



### 소스코드의 평가와 실행

자바스크립트 엔진은 소스코드를 2개의 과정 (소스코드 평가, 소스코드 실행)으로 나누어 처리

- 소스코드 평가
  - 실행 컨텍스트를 생성
  - 변수, 함수 등의 선언문만 먼저 실행
  - 생성된 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프에 등록
- 소스코드 실행(런타임)
  - 변수나 함수의 참조를 실행컨텍스트가 관리하는 스코프에서 검색해서 취득
  - 소스코드의 실행결과는 다시 실행컨텍스트가 관리하는 스코프에 등록됨



### 실행 컨텍스트의 역할

```js
// 전역 변수 선언
const x = 1;
const y = 2;

// 함수 정의
function foo(a) {
  // 지역 변수 선언
  const x = 10;
  const y = 20;

  // 메서드 호출
  console.log(a + x + y); // 130
}

// 함수 호출
foo(100);

// 메서드 호출
console.log(x + y); // 3
```

##### 1. 전역 코드 평가

- 전역 코드를 실행하기 전에 전역 코드 평가 과정을 거쳐 전역 코드 실행을 준비
- 선언문만 먼저 실행
  - `const x; const y;`

- 생성된 전역 변수와 전역 함수가 실행 컨텍스트가 관리하는 전역 스코프에 등록됨
- 이때 `var`키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 객체의 프로퍼티와 메서드가 됨

##### 2. 전역 코드 실행

- 평가 과정이 끝나면 런타임이 시작되어 코드가 순차적으로 실행

- 전역 변수에 값이 할당되고 함수가 호출됨
  - `x = 1; y = 1;`
- 함수가 호출되면 전역코드의 실행을 중단하고 코드 실행 순서를 변경하여 함수 내부로 진입함
  - `foo(100);`

##### 3. 함수 코드 평가

- 함수 내부로 진입하면 내부의 문들을 실행하기 전에 함수 코드 평가 과정을 거치며 준비한다.

- 매개변수와 지역 변수 선언문이 먼저 실행되고 실행 컨텍스트가 관리하는 지역 스코프에 등록됨
  - `var a`, `const x; const y;`
- `arguments` 객체가 생성되어 지역 스코프에 등록되고, `this` 바인딩도 결정된다.

##### 4. 함수 코드 실행

- 평가 과정이 끝나면 런타임이 시작되어 코드가 순차적으로 실행

- 매개변수와 지역 변수에 값이 할당되고 console.log() 메서드가 호출된다. 
  - `x = 10; y = 10;`
  - `console.log(a + x + y);`
- `console` 식별자는 스코프 체인을 통해 검색한다.
  - 현재 스코프에 없으면 상위 스코프로 올라가서 검색

---

**실행 컨텍스트는 소스코드를 실행하는 데 필요한 환경을 제공하고 코드의 실행결과를 실제로 관리하는 영역**

**실행 컨텍스트는 식별자를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘으로, 모든 코드는 실행 컨텍스트를 통해 실행되고 관리됨**

- 식별자와 스코프는 실행컨텍스트의 렉시컬환경으로 관리
- 코드 실행 순서는 실행 컨텍스트 스택으로 관리



### 실행 컨텍스트 스택

- 실행 컨텍스트 스택: 코드의 실행 순서를 관리하는 것
  - LIFO(후입선출) 구조
  - **실행 컨텍스트 스택의 최상위에 존재하는 실행 컨텍스트는 언제나 현재 실행중인 코드의 실행 컨텍스트 === 실행중인 실행 컨텍스트**



### 렉시컬 환경

- 렉시컬 환경: 식별자와 식별자에 바인딩된 값, 상위 스코프에 대한 참조를 기록하는 자료구조
  - 실행 컨텍스트를 구성하는 컴포넌트
- 렉시컬 환경의 컴포넌트 구성
  - 환경 레코드
    - 스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소
  - 외부 렉시컬 환경에 대한 참조
    - 상위 스코프를 가르킴(실행 컨텍스트를 생성한 소스코드를 포함하는 상위코드의 렉시컬 환경을 의미)
    - 스코프체인 구현



### 실행 컨텍스트의 생성과 식별자 검색과정

```js
var x = 1;
const y = 2;

function foo (a) {
  var x = 3;
  const y = 4;

  function bar (b) {
    const z = 5;
    console.log(a + b + x + y + z);
}
  bar(10);
}

foo(20); // 42
```

#### 1. 전역 객체의 생성

- 전역 객체는 전역 코드가 평가되기 이전에 생성
- 전역 객체도 프로토타입 체인의 일원임

#### 2. 전역 코드 평가

- **전역 코드 평가의 순서**

  1. 전역 실행 컨텍스트 생성

  2. 전역 렉시컬 환경 생성

     2.1. 전역 환경 레코드 생성

     ​	2.1.1. 객체 환경 레코드 생성

     ​	2.1.2. 선언적 환경 레코드 생성

     2.2. this 바인딩

     2.3. 외부 렉시컬 환경에 대한 참조 결정

  

- 전역 실행 컨텍스트 생성

  - 비어있는 전역 실행 컨텍스트를 생성하여 실행 컨텍스트 스택에 푸시

- 전역 렉시컬 환경 생성

  - 전역 렉시컬 환경을 생성하고 전역 실행 컨텍스트에 바인디

- 전역 환경 레코드 생성

  - 전역 환경 레코드: 전역 렉시컬 환경을 구성하는 컴포넌트
    - 전역 스코프, 빌트인 전역 프로퍼티, 빌트인 전역 함수, 표준 빌트인 객체 제공

  - 전역 환경 레코드는 객체 환경 레코드와 선언적 환경 레코드로 구성
    - var 키워드로 선언한 전역 변수와 let,const 키워드로 선언한 전역변수를 구분하여 관리하기 위해
    - 서로 협력하여 전역 스코프와 전역 객체를 관리

- 객체 환경 레코드 생성

  - 전역 코드 평가 과정에서 var키워드로 선언한 전역변수와 함수 선언문으로 정의된 전역 함수는 전역 환경 레코드의 객체 환경 레코드에 연결된 BindingObject를 통해 전역 객체의 프로퍼티와 메서드가 됨

- 선언적 환경 레코드 생성

  - let, const 키워드로 선언한 전역 변수(함수 표현식 포함)는 선언적 환경 레코드에 등록되고 관리됨
  - 런타임에 실행 흐름이 변수 선언문에 도달하기 전까지 **일시적 사각지대(TDZ: Temporal Dead Zone)**에 빠지게 됨(초기화 단계)

- this 바인딩

  - 전역 환경 레코드 [[GlobalThisValue]] 내부 슬롯에 this가 바인딩됨
  - 전연 코드에서 this는 전역 객체를 가리킴
  - this 바인딩은 전역 환경 레코드와 함수 환경 레코드에만 존재

- 외부 렉시컬 환경에 대한 참조 결정

  - 현재 평가 중인 소스코드를 포함하는 외부 소스크드의 렉시컬 환경, 즉 상위 스코프를 가르킴
  - 이를 통해 스코프 체인 구현
  - 전역 코드를 포함하는 소스코드는 없으므로 외부 렉시컬 환경에 대한 참조는 null이 할당됨

#### 3. 전역 코드 실행

- 변수 할당문이 실행되고 함수 호출문을 실행함
  - 그 전에 선언된 식별자인지 확인해야함
    - 동일한 이름의 식별자가 다른 스코프에 여러 개 존재 가능
    - 때문에 식별자 결정(어느 스코프의 식별자를 참조하면 되는지 결정하는 것)이 필요
- 식별자 결정을 위해 식별자를 검색할 때는 실행 중인 실행 컨텍스트에서 식별자를 검색하기 시작

#### 4. foo 함수 코드 평가

- 함수 코드 평가 순서

  1. 함수 실행 컨텍스트 생성

  2. 함수 렉시컬 환경 생성

     2.1. 함수 환경 레코드 생성

     2.2. this 바인딩

     2.3. 외부 렉시컬 환경에 대한 참조 결정

  

- 함수 실행 컨텍스트 생성

  - foo 함수 실행 컨텍스트를 생성 후에 함수 렉시컬 환경이 완성되면 실행 컨텍스트 스택에 푸시함

- 함수 렉시컬 환경 생성

  - foo 함수 렉시컬 환경을 생성하고 foo함수 실행 컨텍스트에 바인딩

- 함수 환경 레코드 생성

  - 매개 변수, arguments 객체, 함수 내부에 선언한 지역 변수와 중첩 함수를 등록하고 관리

- this 바인딩

  - 함수 환경 레코드의 [[ ThisValue ]] 내부 슬롯에 this가 바인딩 됨
  - this는 함수 호출 방식에 따라 결정 됨

- 외부 렉시컬 환경에 대한 참조 결정

  - 함수 정의가 평가된 시점에 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 할당됨
  - 외부 렉시컬 환경에 대한 참조에 전역 렉시컬 환경의 참조가 할당됨

#### 5. foo 함수 코드 실행

- 런타임 실행
  - 매개변수에 인수가 할당됨
  - 변수 할당문 실행됨
  - 함수가 호출됨
- 식별자 결정을 위해 실행중인 컨텍스트의 렉시컬 환경에서 식별자를 검색하기 시작함

#### 6. bar 함수 코드 평가

- 렉시컬 환경의 생성과정은 foo 함수와 동일

#### 7. bar 함수 코드 실행

- 런타임이 실행되어 매개변수에 인수 할당, 변수할당문 실행, console.log() 메서드 실행됨

##### console.log(a + b + x + y + z) 실행 과정

1. console 식별자 검색
2. log 메서드 검색
3. 표현식 a + b + x + y + z 평가
4. console.log 메서드 호출

#### 8. bar 함수 코드 실행 종료

- bar 함수 실행 컨텍스트가 팝되어 제거됨
  - foo 실행 컨텍스트가 실행중인 실행 컨텍스트가 됨
- 모든 값은 누군가 의해 참조되지 않을 때 비로소 가비지 컬렉터에 의해 메모리 공간의 확보가 해제되어 소멸함

#### 9. foo 함수 코드 실행 종료

- foo 함수 실행 컨텍스트가 팝되어 제거됨
  - 전역 실행 컨텍스트가 실행중인 실행 컨텍스트가 됨

#### 10. 전역 코드 실행 종료

- 팝되어 실행 컨텍스트 스택에는 아무것도 남아있지 않게 됨



### 실행 컨텍스트와 블록 레벨 스코프

- var 키워드로 선언한 변수는 함수 레벨 스코프만 따름

- let, const로 선언한 변수는 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따름

- ```js
  let x = 1;
  
  if (true) {
    let x = 10;
    console.log(x); // 10
  }
  
  console.log(x); // 1
  ```

  - if문 내에서 코드 블록이 실행되면 if문의 코드 블록을 위한 블록 레벨 스코프를 생성해야 함

  - 새롭게 실행된 if 문의 코드 블록을 위한 렉시컬 환경의 외부 렉시컬 환경에 대한 참조는 if 문이 실행 되기 이전의 전역 렉시컬 환경을 가르키게 됨

## `❗️ 읽은 소감`

> 실행 컨텍스트는 평가후 실행을 하며 실행 컨텍스트 스택이란 LIFO 구조에 Push를 하여 실행을 한후, pop을 통해 종료를 한다. 실행 컨텍스트는 자바스크립트 엔진에서 중요한 역할을 하며, 동작원리를 개발자가 이해하기 쉽게 만드는 것 같았다. 또한 스코프체인이 자주 일어나 변수가 어떻게 저장되고 처리하는지, let과 const는 호이스팅이 일어나는데 var와 어떻게 다른지 알게되는 시간이 되었다.

## `❓ 궁금한 내용이나 잘 이해되지 않는 내용`

- 없음

