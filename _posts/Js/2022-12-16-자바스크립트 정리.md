---
title: 자바스크립트 정리(22.12.19 수정)
date: 2022-12-16 +/-TTTT
categories: [JavaScript, Interview]
tags: [react] # TAG names should always be lowercase
---

# 🔖 자바스크립트 정리

### 자바스크립트 탄생

- 1995년, 넷스케이프 커뮤니케이션즈에서 웹페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경량형 프로그래밍 언어를 도입하기로 결정하였는데 이것이 브래던 아이크가 개발한 자바스크립트이다.



### 크로스 브라우징 이슈

- 넷스케이프 커뮤니케이션즈와 마이크로소포트는 자사 브라우저의 점유율을 높이기 위해 자사 브라우저에서만 동작하는 기능을 경쟁적으로 추가하기 시작하였다.

- 브라우저에 따라 웹페이지가 정상적으로 동작하지 않는 크로스 브라우징 이슈가 발생하였다.



### ECMAScript 등장

- 자바스크립트의 파편화를 방지하고 모든 브라우저에서 정상적으로 동작하는 표준화된 자바스크립트의 필요성이 느껴 1997년 7월에 ECMA-262라고 불리는 표준화된 자바스크립트 초판 사양이 완성되었고 상표권 문제로 ECMAScript로 명명되었다.



### ES6 등장

- let/const 키워드
- 화살표 함수
- 템플릿 리터럴
- 디스트럭처링 할당
- 스프레드 문법
- rest 파라미터
- 심벌
- 프로미스
- Map/Set
- 이터러블
- for...of
- 제너레이터
- Proxy
- 모듈 import/export



### 렌더링

- HTML, CSS, 자바스크립트로 작성된 문서를 해석하여 브라우저에 시각적으로 출력하는 것을 의미한다.

- 때로는 서버에서 데이터를 HTML로 변환해서 브라우저에게 전달하는 과정(SSR)을 가리키기도 한다.



### AJAX

- 자바스크립트를 이용하여 서버와 브라우저가 비동기방식으로 데이터를 교환할 수 있는 통신기능을 의미한다.

- Ajax의 등장으로 웹페이지에서 변경할 필요가 없는 부분은 다시 렌더링 하지않고, 서버로부터 필요한 데이터만 전송받아 변경해야 하는 부분만 한정적으로 렌더링하는 방식이 가능해졌다.

- 예시로 2005년 구글 맵스가 있다.



### JQuery

- 2006년, DOM을 더욱 쉽게 제어할 수 있고 크로스 브라우징이슈도 어느정도 해결가능한 JQuery가 등장하였다.



### Node.js

- 구글V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경을 의미한다.

- 자바스크립트를 브라우저 이외의 환경에서 동작할 수 있도록 자바스크립트 엔진을 브라우저에서 독립시킨 자바스크립트 실행 환경이다.

- 서버 사이드 애플리케이션 개발에 주로 사용되며 이에 필요한 모듈, 파일 시스템, HTTP 등 빌트인 API를 제공한다.

- 프론트엔드와 백엔드 영역에서 자바스크립트를 사용할 수 있는 동형성을 가지고 있다.

- 비동기 I/O를 지원하고 단일 스레드 이벤트 루프 기반으로 동작하여 요청처리 성능이 좋다.

- 데이터를 실시간으로 처리하기 위해 I/O가 빈번하게 발생하는 SPA에 적합하다.

- CPU 사용률이 높은 애플리케이션에는 권장하지 않는다.



### NPM

- 노드 패키지 매니저는 자바스크립트 패키지 매니저이다.
- Node.js에서 사용할 수 있는 모듈들을 패키지화해서 모아둔 저장소 역할과 패키지 설치 및 관리를 위한 CLI를 제공한다.



### SPA

- 최초 한번 페이지 전체를 로딩한 후, 데이터만 변경하여 사용할 수 있는 애플리케이션을 의미한다.

- CSR이다.



### 자바스크립트 특징

- HTML, CSS와 함께 웹을 구성하는 요소중 하나로 웹브라우저에서 동작하는 유일한 프로그래밍 언어이다.
- 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어이다.
- 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어다.
- 프로토타입 기반의 객체지향 언어이다.



### 웹 크롤링

- 서버에서 웹사이트의 콘텐츠를 수집하기위해 웹사이트에서 HTML 문서를 가져온 다음, 이를 가공해서 필요한 데이터만 추출하는 것을 의미한다.



### 변수

- 값을 저장하기 위한 메모리공간의 이름을 의미한다.
- 값을 재사용하기 위하여 사용한다.



### 식별자

- 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 의미한다.
- 변수를 식별자라고도 한다.



### 키워드

- 자바스크립트 코드를 해석하고 실행하는 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어이다.



### 선언과 초기화

- 선언단계: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
- 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.



### 호이스팅

- 모든 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 고유한 특징이다.



### 가비지 콜렉터

- 애플리케이션이 할당한 메모리공간을 주기적으로 검사하여 더이상 사용되지 않는 메모리를 해제하는 기능을 의미한다.
- 메모리 누수를 방지한다.



### 네이밍 컨벤션

- 하나 이상의 영어 단어로 구성된 식별자를 만들 때 가독성 좋게 단어를 한눈에 구분하기 위해 규정한 명명 규칙이다.

- 자바스크립트에서는 변수나 함수에 이름에는 카멜케이스를 사용하고 클래스의 이름, 생성자 함수는 파스칼 케이스를 사용한다.



### 예약어

- 프로그래밍 언어에서 사용되고 있거나 사용될 예정인 단어를 의미한다.



### 값

- 식이 평가되어 생성된 결과를 의미한다.



### 리터럴

- 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 의미한다.



### 표현식

- 값으로 평가될 수 있는 문이다.

- 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.



### 문

- 프로그램을 구성하는 기본 단위이자 최소 실행 단위다.
- 문은 여러 토큰으로 구성된다.
  - 토큰: 문법적인 의미를 가지며 문법적으로 더이상 나눌 수 없는 코드의 기본 요소를 의미한다.



### 데이터 타입

- 자바스크립트는 7개의 데이터 타입을 가지고있다.
  - 원시타입
    - 숫자 타입: 정수와 실수 구분없이 모든 수를 실수처리하여 하나의 숫자타입이 존재한다.
    - 문자열 타입: 문자열을 가진다.
    - 불리언 타입: 논리적 참과 거짓을 가진다.
    - undefined 타입: var 키워드로 선언된 변수에 암묵적으로 할당되는 값이다.
    - null 타입: 값이 없다는 것을 의도적으로 명시할 때 사용하는 값이다.
    - Symbol 타입: 다른 값과 중복되지 않는 유일무일한 값이다. 주로 이름 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.
  - 객체타입
    - 객체
    - 함수
    - 배열



### 데이터 타입의 필요성

- 데이터 타입에 의한 메모리 공간의 확보와 참조
- 데이터 타입에 의한 값의 해석
  - 값을 저장할때 확보해야하는 메모리 공간의 크기를 결정하기 위해
  - 값을 참조할때 한번에 읽어 들여야할 메모리 공간의 크기를 결정하기 위해
  - 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해



### 동적 타이핑

- 자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정된다.(타입추론)
- 재할당에 의해 변수의 타입은 언제든 동적으로 변할 수 있다. 
- 동적 타입 언어는 유연성은 높으나 신뢰성은 떨어진다.



### 동등/일치 비교연산자(==/===)

- 동등비교(==) 연산자는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적으로 타입 변환을 통해 타입을 일치 시긴 후 같은 값인지 비교한다.
- 일치비교(===) 연산자는 암묵적 타입변환을 하지않고 값을 비교한다.
  - typeof 연산자는 일치비교연산자와 동일하게 동작하지만, null은 object로 반환되는 버그가 존재하기 때문에 일치연산자를 사용하는 것을 권장한다.



### 타입 변환

- 명시적 타입 변환(타입 캐스팅): 개발자가 의도적으로 값의 타입을 변환 하는 것
- 암묵적 타입 변환(타입 강제 변환): 개발자의 의도와 상관없이 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 변환 되는 것

- 타입 변환은 기존 원시 값을 직접 변경하지 않고 다른 타입의 새로운 원시 값을 생성하는 것이다.



### 단축 평가

- 표현식이 평가하는 도중 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 의미한다.
- 단축평가의 활용
  - 객체를 가리키기 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때
  - 함수 매개변수에 기본값을 설정할 때



### 옵셔널 체이닝 연산자(`?.`)

- ES11에서 도입되었다.
- 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환하고 그렇지 않으면 우항의 프로퍼티 참조를 이어가는 것을 의미한다.
- 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때 유용하다.



### null 병합 연산자 (`??`)

- ES11에서 도입되었다.
- 좌항의 피연산자가 null 또는 undefined일 경우 우항의 피연산자를 반환하고 그렇지 않으면 좌항의 피연산자를 반환한다.
- 변수에 기본값을 설정할때 유용하다.



### 객체

- 자바스크립트는 객체 기반의 프로그래밍 언어이며 자바스크립트를 구성하는 거의 모든 것이 객체다.
  - 원시 값을 제외한 나머지 값들은 모두 객체다.
- 객체 타입은 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조이다.
- 객체는 변경 가능한 값이다.
- 0개 이상의 프로퍼티로 구성된 집합이며 프로퍼티는 키와 값으로 구성된다.
- 프로퍼티: 객체의 상태를 나타내는 값
- 메서드: 프로퍼티를 참조하고 조작할 수 있는 동작
- 상태와 동작을 하나의 단위로 구조화 할 수 있어 유용하다.



### 인스턴스

- 클래스에 의해 생성되어 메모리에 저장된 실체를 의미한다.

- 객체 = 클래스 + 인스턴스



### 객체 생성 방법

- 객체 리터럴
  - 가장 일반적이고 간단한 방법
  - 프로퍼티를 동적으로 추가할 수 있다.
- Object 생성자 함수
- 생성자 함수
- Object.create 메서드
- 클래스(ES6)



### 프로퍼티

- 객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.

- 프로퍼티 키: 빈 문자열을 포함하는 모든 문자열 또는 심벌 값
- 프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값



### 메서드

- 프로퍼티의 값이 함수일 경우 일반 함수와 구분하기 위해서 지칭하는 것이다.



### 프로퍼티 접근(마침표 표기법과 대괄호 표기법)

- 마침표 표기법: `.`
- 대괄호 표기법: `[...]`
  - 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 된다.
- 객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환한다.



### 원시 값과 객체의 비교

- 원시값
  - 원시 값은 변경 불가능한 값이다.
  - 원시 값을 변수에 할당하면 변수에는 실제 값이 저장된다.
  - 원시 값을 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달한다. (값에 의한 전달/pass by value)
  - 원시값은 불변성(immutability)이다.
- 객체
  - 객체는 변경 가능한 값이다.
  - 객체를 변수에 할당하면 변수에는 참조 값이 저장된다.
  - 객체를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달한다. (참조에 의한 전달/pass by reference)



### 자바스크립트 객체의 관리 방식

- 프로퍼티 키를 인덱스로 사용하는 해시 테이블(연관 배열, map)이라고 생각하면 된다.
- V8 자바스크립트 엔진에서는 프로퍼티에 접근하기 위해 동적탐색 대신 히든 클래스 방식을 사용해 C++객체의 프로퍼티에 접근하는 정도의 성능을 보장한다.



### 얕은 복사와 깊은 복사

- 얕은 복사: 한 단계 까지만 복사하는 것을 의미한다.
  - 객체에 중첩되어 있는 객체의 경우 참조 값을 복사한다.
  - 객체에 할당한 변수를 다른 변수에 할당하는 경우를 의미한다.
  - 스프레드 문법으로도 얕은 복사가 가능하다.
- 깊은 복사: 객체에 중첩되어있는 객체까지 모두 복사하는 것을 의미한다.
  - 객체에 중첩되어 있는 객체의 경우 중첩되어 있는 객체까지 모두 복사해서 원시 값처럼 완전한 복사본을 만든다.
  - 원시 값을 할당한 변수를 다른 변수에 할당하는 경우를 의미한다.
  - Nods.js의 lodash으로도 깊은 복사가 가능하다.



### 함수

- 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.
- 매개변수: 함수 내부로 입력을 전달받는 변수
- 인수: 입력
- 반환값: 출력
- 함수는 객체이다.
  - 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.
- 함수는 **한가지 일**만 해야하며 가급적 **작게** 만들어야 한다.



### 함수를 사용하는 이유

- 코드의 **재사용**에서 매우 유용하기 때문이다.
- 유지보수의 **편의성**을 높이고 실수를 줄여 코드의 **신뢰성**을 높힌다.
- 코드의 **가독성**을 향상시킨다.



### 함수 정의

- 함수 선언문
  - 표현식이 아닌 문이기 때문에 함수 이름을 생략할 수 없다.
  - 자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.
  - 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.
  - 함수 호이스팅이 발생한다.
- 함수 표현식
  - 표현식인 문이기 때문에 함수 이름을 생략 가능하다.
  - 변수 호이스팅이 발생한다.
- Function 생성자 함수
  - 클로저를 생성하지 않고 함수 선언문이나 표현식으로 생성한 함수와 다르게 동작한다.
- 화살표 함수
  - 항상 익명함수로 정의한다.
  - 표현과 내부 동작이 간략화되어 있다.
  - this 바인딩이 다르다.
  - prototype 프로퍼티가 없고 arguments 객체를 생성하지 않는다.



### 즉시 실행 함수(IIFE)

- 함수 정의와 동시에 즉시 호출되는 함수를 의미한다.
- 단 한번만 호출되며 다시 호출할 수 없다.
- 변수에 할당하여 인수를 전달할 수 있다.

```javascript
(function () {
	var a = 1;
	var b = 2;
	return a * b;
}());
```



### 재귀 함수

- 함수가 자기 자신을 호출하여 작동하는 함수를 의미한다.
- 재귀 함수를 사용하여 반복되는 처리를 반복문 없이 구현할 수 있다.
- 탈출 조건이 반드시 필요하다.
  - 탈출 조건이 없으면 함수가 무한 호출되어 스택 오버플로 에러가 발생한다.

```javascript
function countdown(n) {
  if (n < 0) return;
  console.log(n)
  countdown(n - 1)
}
countdown(10)
```



### 중첩 함수(내부 함수)

- 함수 내부에 정의된 함수를 의미한다.
- 외부 함수: 중첩함수를 포함하는 함수를 의미한다.

- 중첩 함수는 외부 함수 내부에서만 호출이 가능하다.
- 중첩 함수는 외부 함수를 돕는 헬퍼 함수의 역할을 한다.



### 콜백 함수

- 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 의미한다.
  - 함수형 프로그래밍 패러다임과 비동기처리(이벤트 처리, Ajax 통신, 타이머 함수)에 활용된다.
- 고차 함수: 매개 변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 의미한다.
  - 콜백 함수를 자신의 일부분으로 합성한다.
  - 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해 호출한다.
- 콜백함수는 고차 함수에 의해 호출되며 고차함수는 필요에 따라 콜백함수에 인수를 전달할 수있다.



### 부수 효과(Side Effect)

- 어떤 외부 상태에 의존하여 외부 상태를 변경되는 것을 의미한다.



### 순수 함수와 비순수 함수

- 순수 함수: 부수효과가 없는 함수를 의미한다.
  - 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.
  - 매개변수가 있는 것
- 비순수 함수: 부수효과가 있는 함수를 의미한다.
  - 매개변수가 없어도 외부상태가 변하는 것



### 함수형 프로그래밍

- 순수 함수를 통해 부수 효과를 최대한 억제하여 오류를 피하고, 프로그램의 안정성을 높이려는 프로그래밍 패러다임을 의미한다.



### 스코프(유효범위)

- 식별자가 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위를 결정하는 것을 의미한다.

- 식별자가 유효한 범위를 의미한다.

- 식별자를 검색할 때 사용하는 규칙을 의미한다.

- 스코프는 네임스페이스다.



### 스코프 체인

- 스코프가 계층적으로 연결된 것을 의미한다.
- 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하여 선언된 변수를 검색한다.
- 식별자 검색을 위한 메커니즘이라고 할 수 있다.



### 함수 레벨 스코프

- var 키워드로 선언된 변수는 함수의 코드 블록만을 지역 스코프로 인정한다.



### 블록 레벨 스코프

- let, const 키워드로 선언된 변수는 블록을 지역스코프로 인정한다.



### 렉시컬 스코프(정적 스코프)

- 함수를 어디서 정의하는지에 따라 상위 스코프를 결정한다.
- 함수의 상위 스코프는 언제나 자신이 정의된 스코프다.
- 함수 정의가 실행되어 생성된 객체는 결정된 상위 스코프를 기억한다. 
  - 함수가 호출될 때마다 함수의 상위스코프를 참조할 필요가 있기 때문이다.
- 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정된다.



### 전역 객체

- 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체를 의미한다.
- 표준 빌트인 객체와 호스트객체, 전역변수와 전역 함수를 프로퍼티로 갖는다.



### 지역 변수

- 지역 변수의 생명 주기는 함수의 생명 주기와 일치한다.
- 스코프를 참조하고 있으면 스코프는 소멸하지 않고 생존하게 된다.



### 전역 변수

- 단점

  - 모든 코드가 전역 변수를 참조하고 변경할 수 있는 **암묵적 결합**을 허용하는 것이 단점이다.
    - 변수의 유효 범위가 크면 클수록 코드의 가독성이 나빠지고 의도치 않게 상태가 변경될 수 있는 위험도 있다.

  - 긴 생명 주기
  - 스코프 체인 상에서 종점에 존재
    - 전역 변수의 검색 속도가 가장 느리다.
  - 네임스페이스 오염
    - 파일이 분리되어 있어도 하나의 전역 스코프를 공유한다.

- 전역 변수 사용의 억제

  - 변수의 스코프는 좁을수록 좋다

  - 즉시 실행 함수(라이브러리 등에 자주 사용)

  - 네임스페이스 객체(식별자 충돌 방지는 효과가 있으나 결국 전역 변수에 할당되는 것이다.)

  - 모듈 패턴

    - 클래스를 모방해서 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만드는 것이다.
    - 전역 변수의 억제와 캡슐화 구현이 가능하다는 특징이 있다.

  - ES6 모듈

    - 전역 변수를 사용할 수 없게 된다.

    - 파일 자체의 독자적인 모듈 스코프를 제공한다.

    - ```html
      <script type="module" src="app.mjs"></script>
      ```

    - 트랜스파일링이나 번들링이 필요하기 때문에 ES6 모듈보다 모듈 번들러를 사용하는 것이 일반적이다.



### 캡슐화

- 프로퍼티와 메서드를 하나로 묶는 것을 의미한다.
  - 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것을 말한다.
  - 정보은닉을 위해 사용한다.

- 정보은닉: 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하는 것이다.
  - 외부에 공개할 필요가 없는 구현의 일부를 외부에 공개되지 않도록 감추어 적철지 못한 접근으로 부터 객체의 상태가 변경되는 것을 방지해 정보를 보호하고, 결합도를 낮추는 효과가 있다.
  - 결합도: 객체간의 상호 의존성을 의미한다.




### var 키워드 문제점

- 변수 중복 선언 허용
  - 의도치 않게 선언된 변수 값을 변경할 수 있는 부작용
- 함수 레벨 스코프
  - 전역 변수를 남발할 가능성이 높음
- 변수 호이스팅
  - 선언과 초기화가 동시에 진행된다.
  - 가독성을 떨어뜨리고 오류를 발생시킬 여지가 있음



### let 키워드

- 변수 중복 선언 허용
- 블록 레벨 스코프
- 변수 호이스팅
  - 선언과 초기화가 분리되어 진행된다.
  - 스코프의 시작 시점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 **일시적사각지대(Temporal Dead Zone:TDZ)**라고 한다.



### const 키워드

- 상수를 선언하기 위해 사용한다.
- 선언과 초기화
  - 반드시 선언과 동시에 초기화 해야한다.
- 재할당 금지
- 상수
  - 재할당이 금지된 변수를 의미한다.
  - 상태 유지와 가독성, 유지보수에 도움이 된다.
  - 상수의 이름은 대문자로 선언해 상수임을 명확하게 나타내며 여러단어로 이루어질 경우 언더코어로 구분해서 스네이크 케이스로 표현한다.
- const 키워드와 객체
  - 객체를 할당한 경우 값을 변경할 수 있다.



### 내부슬롯과 내부 메서드

- 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티, 의사 메서드이다.
- 개발자가 직접 접근할 수 있도록 외부에 공개된 프로퍼티는 아니다. 하지만 일부 내부 슬롯과 내부 메서드에 한하여 간접적으로 접근할 수 있는 수단을 제공하기는 한다.
- 모든 객체는 [[Prototype]] 이라는 내부 슬롯을 갖는다. `__proto__`를 통해 간접적으로 접근할 수 있다.



### 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체

- 자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.

- 프로퍼티 상태: 프로퍼티 값, 값 갱신가능 여부, 열거 가능 여부, 재정의 가능 여부
- Obeject.getOwnPropertyDescriptor 메서드를 사용하여 간접적으로 프로퍼티 어트리뷰트를 확인 가능하다.
- Obeject.getOwnPropertyDescriptors 메서드를 사용하여 모든 프로퍼티의 프로퍼티 어트리뷰트정보를 제공하는 프로퍼티 디스크립터 객체들을 반환한다.



### 데이터 프로퍼티와 접근자 프로퍼티

- 데이터 프로퍼티: 키와 값으로 구성된 일반적인 프로퍼티
  - 데이터 프로퍼티 어트리뷰트: [[Value]], [[Writable]], [[Enumerable]], [[Configurable]] 
- 접근자 프로퍼티: 자체적으로 값을 가지고 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근하 함수로 구성된 프로퍼티
  - 접근자 프로퍼티 어트리뷰트: [[Get]], [[Set]], [[Enumerable]], [[Configurable]]



### 프로퍼티 정의

- 새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의 하는 것을 의미한다.
- Object.defineProperty 메서드로 한번에 하나의 프로퍼티의 어트리뷰트를 정의할 수 있다.
- Object.defineProperties 메서드로 여러 개의 프로퍼티를 한 번에 정의할 수 있다.



### 객체 변경 방지 메서드

- Object.preventExtensions: 삭제, 읽기, 쓰기, 재정의 가능(확장 금지)
  - Object.isExtensible: 확장이 가능한 객체인지 여부를 알 수 있는 메서드
- Object.seal: 읽기, 쓰기 가능(밀봉)
  - Object.isSealed: 밀봉된 객체인지 확인하는 메서드
- Object.freeze: 읽기만 가능(동결)
  - Object.isFrozen: 동결된 객체인지 확인하는 메서드

얕은 변경 방지로 직속 프로퍼티만 변경이 방지되고 중첩 객체까지는 영향을 주지 못한다.

불변 객체를 구현하려면 재귀적으로 사용해야한다.



### 생성자 함수

- new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 의미한다.

- 인스턴스(instance): 생성자 함수에 의해 생성된 객체를 의미한다.
- 역할: 프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 템플릿(클래스)으로서 동작하여 인스턴스를 생성하는 것과 생성된 인스턴스를 초기화(인스턴스 프로퍼티 추가 및 초기값 할당)하는 것
  - 생성자 함수가 인스턴스를 생성하는 것은 필수이며, 생성된 인스턴스를 초기화 하는것은 옵션이다.

- 인스턴스 생성과정
  1. 인스턴스 생성과 this 바인딩
  2. 인스턴스 초기화
  3. 인스턴스 반환
     - return문은 반드시 생략해야 한다.



### 바인딩

- 식별자와 값을 연결하는 과정을 의미한다.



### 내부 메서드 [[Call]]과 [[Construct]]

- 함수가 일반 함수로서 호출되면 함수 객체의 내부 메서드 [[Call]]이 호출되고, new 연산자와 함께 생성자 함수로서 호출되면 내부 메서드 [[Construct]]가 호출된다.
- callable: 내부 메서드 [[Call]]을 갖는 함수 객체
  - 즉, 함수를 의미한다.
- constructor: 내부 메서드 [[Construct]]를 갖는 함수 객체, 생성자 함수로서 호출할 수 있는 함수를 의미한다.
  - 예시) 함수 선언문, 함수 표현식, 클래스
- non-constructor: 객체를 생성자 함수로서 호출할 수 없는 함수를 의미한다.
  - 예시) 메서드(ES6 메서드 축약 표현), 화살표 함수

모든 함수는 호출할 수 있지만, 모든 함수 객체를 생성자 함수로서 호출할 수 있는 것은 아니다.



### new.target(메타 프로퍼티)

- 생성자 함수가 new 연산자 없이 호출되는 것을 방지하기 위해 파스칼 케이스 컨벤션을 사용한다 하더라도 실수는 언제나 발생할 수 있다.
- 이런 위험성을 회피하기 위해 ES6에서 new.target을 지원한다.
- new 연산자와 함께 생성자 함수로서 호출되면 함수 내부의 new.target은 함수 자신을 가르킨다.
- new 연산자 없이 일반 함수로서 호출된 함수 내부의 new.target은 unedfined다.



### 일급 객체

1. 무명의 리터럴로 생성할 수 있다.
2. 변수나 자료구조에 저장할 수 있다.
3. 함수의 매개변수에 전달할 수 있다.
4. 함수의 반환값으로 사용할 수 있다.

이 조건에 만족하는 객체를 일급 객체라고 하며 자바스크립트에서는 함수도 일급 객체이다.



### 함수 객체의 프로퍼티

- arguments: 함수 호출 시 인수들의 정보를 담고 있는 순회 가능한(iterable) 유사 배열 객체이며, 함수 내부에서 지역 변수처럼 사용된다.
  - 매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용하다.

- caller: ECMAScript 사양에 포함되지 않은 비표준 프로퍼티이며, 함수 자신을 호출한 함수이다.

- length: 함수를 정의할 때 선언한 매개변수의 개수이다.
  - arguments 객체의 length 프로퍼티는 인수의 개수, 함수 객체의 length 프로퍼티는 매개변수의 개수를 가리킨다.

- name: 함수의 이름을 나타낸다.

- prototype: 생성자 함수로 호출할 수 있는 함수 객체, 즉 constructor만이 소유하는 프로퍼티이다.



### 자바스크립트

- 명령형, 함수형, 프로토타입 기반 객체 지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어이다.



### 객체 지향 프로그래밍

- 여러 개의 독립 적 단위인 객체를 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 의미한다.
- 실세계의 실체를 인식하는 철학적사고를 프로그래밍에 접목하려는 시도에서 시작된다.



### 객체

- 상태와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료구조이다.
- 프로퍼티와 메서드로 구성되어 있다.



### 추상화

- 다양한 속성 중에서 프로그램에 필요한 속성만 간추려 내는 것



### 상속

- 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 의미한다.
- 자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거한다.



### 프로토타입 객체

- 객체지향 프로그래밍의 근간을 이루는 객체 간 상속을 구한하기위해 사용되는 것이다.
- 프로토타입은 어떤 객체의 상위 객체의 역할을 하는 객체이다. 다른 객체에 공유 프로퍼티를 제공한다.



### `__proto__` 접근자 프로퍼티

- 모든 객체는 `__proto__` 접근자 프로퍼티를 통해 자신의 프로퍼티 즉, [[Prototype]] 내부 슬롯에 간접적으로 접근할 수 있다.

- `__proto__`는 상속을 통해 사용된다.
- 하지만 코드 내에서 `__proto__` 접근자 프로퍼티를 직접 사용하는 것은 권장하지 않는다.
  - 모든 객체가 `__proto__` 접근자 프로퍼티를 사용하는 것은 아니기 때문이다.
  - 예를 들어 직접 상속을 받았을 때를 말한다.
  - 때문에, 프로토타입의 교체를 하고 싶을 경우 Object.getPrototypeOf 메서드와  Object.setPrototypeOf 메서드를 사용하는 것을 권장한다.



### `__proto__`를 통해 프로토타입에 접근하는 이유

- 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위해 사용한다.
- 프로토타입 체인은 단뱡향 링크드 리스트로 구현해야한다.
  - 검색방향이 한쪽으로 흘러가는 것을 의미한다.



### 함수 객체의 prototype 메서드

- 함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.



### 객체 리터럴과 object 생성자 함수의 차이

- 추상 연산 OrdinaryObjectCreate를 호출하여 빈 객체를 생성하는 것은 동일하다.
- new.target의 확인이나 프로퍼티를 추가하는 처리 등 세부 내용이 다르다.



### 프로토타입의 생성 시점

- 생성자 함수가 실행되는 시점에 생성된다.
  - 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재하기 때문이다.



### 프로토타입 체인

- 프로토타입 체인: 자바스크립트는 객체의 프로퍼티에 접근하려고 할 때, 해당 객체에 접근하려는 프로퍼티가 없다면 [[Prototype]] 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다.
- 자바스크립트가 객체 지향 프로그래밍의 상속을 구현하는 메커니즘이다.
- 프로토타입 체인은 상속과 프로퍼티 검색을 위한 메커니즘이라고 할 수 있다.

- 스코프 체인과 프로토타입 체인은 서로 협력하여 식별자와 프로퍼티를 검색하는데 사용된다.



### 프로퍼티 섀도잉

- 상속관계에 의해 프로퍼티가 가려지는 현상을 의미한다.



### 오버라이딩

- 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의 하여 사용하는 방식이다.



### 오버로딩

- 함수의 이름은 동일하지만 매개변수의 타입 또는 개수가 다른 메서드를 구현하고 매개변수에 의해 메서드를 구별하여 호출하는 방식이다.
- 자바스크립트는 오버로딩을 지원하지 않지만, arguments 객체를 사용하여 구현할 수 있다.



### instance of 연산자

- 우변의 생성자 함수의 prototype에 바인딩된 객체가 좌변의 객체의 프로토타입 체인 상에 존재하면 true를 반환하고, 그렇지 않는 경우에는 false로 반환한다.



### Object.create에 의한 직접 상속

- Object.create 메서드는 명시적으로 프로토타입을 지정하여 새로운 객체를 만든다.
- 장점
  - new 연산자 없이도 객체 생성 가능
  - 프로토타입을 지정하면서 객체 생성가능
  - 객체 리터럴에 의해 생성된 객체도 상속받을 수 있음
- ESLint에서 이 방식을 권장하지 않음
  - 프로토타입 체인의 종점에 위치하는 객체는 Object.prototype의 빌트인 메서드를 사용할 수 없기 때문이다.



### 정적 프로퍼티와 정적 메서드

- 정적프로퍼티와 정적 메서드는 생성자 함수로 인스턴스를 생성하지 않아도 참조하거나 호출할 수 있는 프로퍼티와 메서드를 의미한다.
- 만약 인스턴스/프토토타입 메서드 내에서 this를 사용하지 않는다면 그 메서드는 정적 메서드로 변경할 수 있다.



### in 연산자 - 프로퍼티 존재 확인 

- 객체 내에 특정 프로퍼티가 존재하는지 여부를 확인한다.

- 확인 대상 객체의 프로퍼티뿐만 아니라 확인 대상 객체가 상속받은 프로토타입의 프로퍼티까지 확인하여 주의가 필요하다.



### Object.prototype.hasOwnPropery 메서드 - 프로퍼티 존재 확인 

- 객체에 특정 프로퍼티가 존재하는지 확인 가능하다.



### for ... in 문 - 프로퍼티 열거

- 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중에서 프로퍼티 어트리뷰트 [[Enumerable]] 값이 true인 프로퍼티를 순회하여 열거한다.
- 순서를 보장하지 않는다.
  - 대부분 모던 브라우저는 순서를 보장하고 숫자인 프로퍼티 키에 대해서는 정렬을 실시한다.



### Object.keys/values/entries 메서드 - 프로퍼티 열거

- 객체 자신의 고유 프로퍼티만 열거하기 위한 메서드이다.
- 열거 가능한 프로퍼티 `키`/`값`/`키와 값의 쌍의 배열`을 배열로 반환한다.



### strict mode(엄격 모드)

- 엄격 모드를 사용하면 자바스크립트 언어의 문법을 좀 더 엄격히 적용하여 오류를 발생시키거나 자바스크립트 엔진의 최적화 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킨다.

- ES6의 클래스와 모듈은 strict mode가 기본적으로 적용된다.
- 코드 선두에 `'use strict';`를 추가하면 적용된다.
  - 전역에 사용하는 것, 함수 단위로 적용하는 것은 권장하지 않는다.



### ESLint

- strict mode와 유사한 효과를 얻을 수 있는 도구이다.
- 정적 분석을 통해 소스코드를 실행하기전에 소스코드를 스캔하여 문법적인 오류와 잠재적 오류를 찾아내고 오류의 원인을 리포팅 해주는 도구이다.



### strict mode가 발생시키는 에러

- 암묵적 전역
- 변수, 함수, 매개변수의 삭제

- 매개변수 이름의 중복
- with 문의 사용



### strict mode 적용에 의한 변화

- 일반함수 this
  - undefined가 반환됨
- arguments 객체
  - 매개변수에 전달된 인수를 재할당하여 변경하여도 arguments 객체에 반영되지 않음



### 빌트인 객체

- 표준 빌트인 객체
  - ECMAScript 사양에 정의된 객체이며 애플리케이션 전역의 공통 기능을 제공한다. 전역 객체의 프로퍼티로서 제공되어 별도의 선언 없이 전역변수처럼 언제나 참조할 수 있다.
- 호스트 객체
  - ECMAScript 사양에 정의되어 있지 않지만, 자바스크립트 실행 환경에서 추가로 제공하는 객체이다.
  - 브라우저 환경: 클라이언트 사이드 Web API 제공
- 사용자 정의 객체
  - 사용자가 직접 정의한 객체를 의미한다.



### 래퍼 객체(wrapper object)

- 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 의미한다.



### URI(Uniform Resource Identifier)

- 인터넷에 있는 자원을 타나내는 유일한 주소를 의미한다.



### URL(Uniform Resource Locator)

- 인터넷에서 웹 페이지, 이미지, 비디오 등 리소스의 위치를 가리키는 문자열을 의미한다.



### URN(Uniform Resource Name)

- 이름으로 리소스를 특정하는 URI를 의미한다.



### 암묵적 전역

- var, let, const 키워드 없이 변수를 선언한 경우, 자바스크립트 엔진은 암묵적으로 전역 객체에 프로퍼티를 동적 생성되어 해당 변수를 마치 전역 변수처럼 사용할 수 있는 것을 의미한다.



### this

- 자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 자기 참조 변수를 의미한다.

- 함수가 호출되는 방식에 따라 this 바인딩이 동적으로 결정된다.

- 함수 호출 방식에 따른 this

  - 일반함수에서 호출(중첩 함수, 콜백 함수)
    - 전역 객체를 가르킨다.


  - 메서드에서 호출
    - 메서드를 호출하는 객체를 가르킨다.


  - 생성자 함수에서 호출
    - 생성자 함수에서 생성될 인스턴스를 가르킨다.


  - `apply` / `call` / `bind` 메서드에 의한 간접 호출

    - apply: this를 원하는 것으로 지정 가능하다. 두번째 인자 형식은 배열로 묶어 전달한다.
    - call: this를 원하는 것으로 지정 가능하다. 두번째 인자 형식은 리스트 형식으로 묶어 전달한다.
    - bind: this를 영구적으로 원하는 것으로 지정 가능하다.

    > ##### apply / call 공통점과 차이점
    >
    > 공통점: 대표적인 용도는 arguments 객체와 유사 배열 객체에 배열 메서드를 사용하는 경우에 쓴다. 비동기 코드에 유리하다.
    >
    > 차이점: 인자의 형식이 다르다.
    >
    > 
    >
    > ##### apply, call / bind 공통점과 차이점
    >
    > 공통점: apply, call, bind는 Function.prototype의 메서드이므로 모든 함수가 상속받아 사용 가능하다.
    >
    > 차이점
    >
    > - bind는 apply와 call 메서드와 달리 함수를 호출하지 않고 this로 사용할 객체만 전달한다
    >
    > - bind 메서드는 메서드의 this와 메서드 내부의 중첩함수 또는 콜백함수의 this가 불일치하는 문제를 해결하기 위해 유용하게 사용한다.




### 실행 컨텍스트

- 자바스크립트의 동작 원리를 담고 있는 핵심 개념이다.

- 소스코드를 실행하는데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.
  - 식별자를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘으로, 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.



### 실행 컨텍스트 스택

- 실행 컨텍스트를 스택 자료구조로 관리하는 것을 의미한다.
- 코드의 실행 순서를 관리하는 것이다.
- 실행 컨텍스트의 최상위에 존재하는 실행 컨텍스트는 실행 중인 실행 컨텍스트이다.



### 렉시컬 환경

- 식별자와 식별자에 바인딩된 값, 상위 스코프에 대한 참조를 기록하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트이다.
- 스코프를 구분하여 식별자를 등록하고 관리하는 저장소의 역할을 하는 것이다.



### 클로저

- 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.

  - 외부함수보다 중첩함수가 더 오래 유지되는 경우, 중첩함수는 이미 생명주기가 다한 외부함수의 변수를 참조할 수 있다. 이러한 중첩함수를 **클로저**라고 한다.

  - 클로저는 중첩 함수가 상위스코프의 식별자를 참조하고 있고 중첩함수가 외부 함수보다 더 오래 유지되는 경우에 한정하는 것이 일반적이다.

  - ```javascript
    const x = 1;
    
    function outerFunc() {
      const x = 10;
      
      function innerFunc() {
        console.log(x); // 10
      }
      
      innerFunc()
    }
    
    outerFunc();
    ```

- 자유변수: 클로저에 의해 참조되는 상위 스코프의 변수를 의미한다.

- 클로저는 자유 변수에 묶여있는 함수라고 할 수 있다.

- 클로저의 활용

  - 상태를 안전하게 변경하고 유지하기 위해 사용한다. (정보 은닉)

  - 특정함수에게만 상태 변경을 허용하기 위해 사용한다.

  - 즉시 실행 함수 활용하여 return을 함수로 반환

  - 즉, 클로저는 상태가 의도치 않게 변경되지 않도록 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하여 상태를 안전하게 변경하고 유지하기 위해 사용한다.

  - ```javascript
    const counter = (function() {
      let counter = 0;
      
      return function (predicate) {
        counter = predicate(counter);
        
        return counter;
      }
    }());
    
    function increase(n) {
      return ++n;
    }
    
    function decrease(n) {
      return --n;
    }
    
    console.log(counter(increase)) // 1
    console.log(counter(increase)) // 2
    
    console.log(counter(decrease)) // 1
    console.log(counter(decrease)) // 0
    ```

    

### 클래스

- 클래스도 함수이며 기존 프로토타입 기반 패턴을 클래스 기반 패턴처럼 사용할 수 있도록 하는 문법적 설탕이다.
  - 클래스를 프로토타입 기반 객체 생성 패턴의 단순한 문법적인 설탕보다 **새로운 객체 생성 메커니즘**이라고 할 수 있다.



### 클래스와 생성자 함수의 차이

- 공통점
  - 인스턴스를 생성한다.
  - 프로토타입 기반의 객체지향을 구현한다는 점에서 유사하다.

- 차이점
  1. 클래스를 new 연산자 없이 호출하면 에러가 발생한다. 하지만 생성자 함수는  new 연산자 없이 호출하면 일반 함수로 호출된다.
  2. 클래스는 상속을 지원하는  extends와 super 키워드를 제공한다. 하지만 생성자 함수는 이 키워드를 제공하지 않는다.
  3. 클래스는 호이스팅이 발생하지 않는 것처럼 동작한다. 하지만 함수 선언문으로 정의된 생성자 함수는 함수 호이스팅이 발생하고, 함수 표현식으로 정의된 생성자 함수는 변수 호이스팅이 발생한다.
  4. 클래스 내의 모든 코드에는 암묵적으로 strict mode가 지정되어 실행되며 strict mode를 해제할 수 없다. 하지만 생성자 함수는 암묵적으로 strict mode가 지정되지 않는다.
  5. 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모드 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false다. 즉, 열거되지 않는다.



### 클래스 호이스팅

- 

---



### REST API

- REST 기반으로 서비스 API를 구현하는 것

  - **REST**: 자원을 이름으로 구분하여 해당 자원의 상태를 주고 받는 모든 것을 의미한다.

  - HTTP URI를 통해 자원을 명시하고 HTTP 메서드를 통해 해당 자원에 대한 CRUD를 적용한다.

    - 즉, 자원 기반의 구조 설계의 중심에 자원이 있고, HTTP 메서드를 통해 이를 처리한다.

  - > ##### API(Application Programming Interface)
    >
    > 응용프로그램에서 사용할 수 있도록 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스이다.
    >
    > - 즉, 프로그램끼리 통신할 수 있도록 하는 중재자이다.
    >
    > 
    >
    > ##### Interface
    >
    > 쉽게 말해 기본설계도를 의미한다. 즉 밑그림과 같다.
    >
    > - 추상 메서드와 상수만이 프로퍼티로 가능하다.
    >
    > - 표준, 약속, 규칙을 의미한다.
    >
    >   
    >
    > ##### 추상화
    >
    > 공통 프로퍼티와 메서드를 뽑아내는 작업을 의미한다.
    >
    > - 복잡한 자료, 모듈, 시스템으로부터 핵심적인 개념 또는 기능을 간추려 내는 것을 의미한다.
    > - 장점: **코드 중복**을 방지할 수 있고 **재사용**을 할 수 있다.
    > - 캡슐화와 정보은닉에 이용된다.
    >
    > 
    >
    > ##### 캡슐화
    >
    > 프로퍼티와 메서드를 묶는 작업을 의미한다.
    >
    > - 중요데이터에 접근하지 못하게 하기 위해 사용한다.
    > - #을 사용하여 private로 가능하다.

- REST API의 특징
  - REST API는 HTTP 표준을 기반으로 구현된다.
  - REST 기반으로 시스템을 분산시켜 확장성, 재사용성을 높여 유지보수와 운용을 쉽게 할 수 있게 만들어준다.



### Restful API

- REST 기반으로 서비스 API를 구현한 것을 의미한다.

- Rest API를 제공하는 웹서비스를 Restful 하다고 할 수 있다.
- 구성
  - 자원, 행위, 표현의 3가지 요소로 구성된다.
    - 자원: URI
    - 행위: HTTP 요청 메서드
    - 표현: 페이로드

- **HTTP API 설계원칙**
  1. **URI**는 리소스를 표현해야한다.
  2. 리소스에 대한 행위는 **HTTP 요청 메서드**로 표현한다.
- **HTTP 메서드**(자주 사용하는 4가지)
  - **GET**: 클라이언트로부터 요청받은 URI 정보를 검색하여 **응답**하는 것
  - **POST**: 클라이언트로부터 요청받은 자원을 **생성**하는 것
  - **PUT**: 클라이언트로부터 요청받은 자원(전체)을 **수정**하는 것
  - **PATCH**: 클라이언트로부터 요청받은 자원(일부)을 **수정**하는 것
  - **Delate**: 클라이언트로부터 요청받은 자원을 **삭제**하는 것





### 자바스크립트의 비동기 코딩

자바스크립트 엔진은 싱글 스레드 방식으로 동작한다.

> ##### 싱글 스레드
>
> 한 번에 하나의 태스크만 실행할 수 있는 것을 의미한다.
>
> ##### 동기처리
>
> 현재 실행 중인 태스크가 종료할 때까지 다음에 실행될 태스크가 대기하는 방식을 의미한다.
>
> 장점: 실행순서가 보장된다.
>
> 단점: 앞의 태스크가 종료할 때까지 이후 태스크들이 블로킹된다.
>
> ##### 비동기처리
>
> 현재 실행 중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식을 의미한다.
>
> 장점: 블로킹이 발생하지 않는다.
>
> 단점: 태스크의 실행순서가 보장되지 않는다.
>
> 비동기 함수: 콜백 패턴을 사용한다.
>
> 비동기 처리 방식: 타이머 함수, HTTP 요청, 이벤트 핸들러

- Proimise
  - ES6에서 도입되어 전통적인 콜백 패턴이 가진 단점을 보완하며 비동기 처리시점을 명확히 표현할 수 있다.
  - .than 메서드는 promise가 처리될때 까지 대기한다.//
  
- 콜백함수
  - 콜백헬이 발동할 수 있다.
    - 가독성이 나빠지고 비동기 처리중 발생한 에러의 예외처리가 곤란하며, 여러 개의 비동기 처리를 한번에 처리하는 데 한계가 있다.
- async / await
  - 프로미스의 후속 처리 메서드 없이 마치 동기처리처럼 프로미스가 처리결과를 반환하도록 구현할 수 있다.
  - async: 해당함수는 항상 promise를 반환한다.
  - await: promise가 처리될때 까지 대기한다.




### 자바스크립트의 동작 원리(이벤트 루프)

- 일반적인 작업은 Call Stack에서 진행한다.
- 시간이 소요되는 작업(setTimeout, Event, HTTP 요청 메서드)들은 Web API 대기 후에 Callback Queue로 보내진다.

- Call Stack이 비워있을 때만 Callback Queue에 저장된 작업들을 Call Stack으로 보낸다.

> ##### 태스크 큐
>
> 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역이다.
>
> ##### 마이크로 큐
>
> 태스크 큐와 별도로 프로미스의 후속 처리 메서드의 콜백 함수가 일시적으로 보관되는 영역이다.
>
> ##### 이벤트 루프 
>
> 콜스택에 현재 실행 중인 실행 컨텍스트가 있는 지, 태스크 큐에 대기 중인 함수가 있는지 반복적으로 확인하는 것을 의미한다.

